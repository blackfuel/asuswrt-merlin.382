menu "Core Netfilter Configuration"
	depends on NET && INET && NETFILTER

config NETFILTER_NETLINK
	tristate

config NETFILTER_NETLINK_QUEUE
	tristate "Netfilter NFQUEUE over NFNETLINK interface"
	depends on NETFILTER_ADVANCED
	select NETFILTER_NETLINK
	help
	  If this option is enabled, the kernel will include support
	  for queueing packets via NFNETLINK.
	  
config NETFILTER_NETLINK_LOG
	tristate "Netfilter LOG over NFNETLINK interface"
	default m if NETFILTER_ADVANCED=n
	select NETFILTER_NETLINK
	help
	  If this option is enabled, the kernel will include support
	  for logging packets via NFNETLINK.

	  This obsoletes the existing ipt_ULOG and ebg_ulog mechanisms,
	  and is also scheduled to replace the old syslog-based ipt_LOG
	  and ip6t_LOG modules.

config NF_CONNTRACK
	tristate "Netfilter connection tracking support"
	default m if NETFILTER_ADVANCED=n
	help
	  Connection tracking keeps a record of what packets have passed
	  through your machine, in order to figure out how they are related
	  into connections.

	  This is required to do Masquerading or other kinds of Network
	  Address Translation.  It can also be used to enhance packet
	  filtering (see `Connection state match support' below).

	  To compile it as a module, choose M here.  If unsure, say N.

if NF_CONNTRACK

config NF_CONNTRACK_MARK
	bool  'Connection mark tracking support'
	depends on NETFILTER_ADVANCED
	help
	  This option enables support for connection marks, used by the
	  `CONNMARK' target and `connmark' match. Similar to the mark value
	  of packets, but this mark value is kept in the conntrack session
	  instead of the individual packets.

config NF_CONNTRACK_SECMARK
	bool  'Connection tracking security mark support'
	depends on NETWORK_SECMARK
	default m if NETFILTER_ADVANCED=n
	help
	  This option enables security markings to be applied to
	  connections.  Typically they are copied to connections from
	  packets using the CONNSECMARK target and copied back from
	  connections to packets with the same target, with the packets
	  being originally labeled via SECMARK.

	  If unsure, say 'N'.

config NF_CONNTRACK_ZONES
	bool  'Connection tracking zones'
	depends on NETFILTER_ADVANCED
	depends on NETFILTER_XT_TARGET_CT
	help
	  This option enables support for connection tracking zones.
	  Normally, each connection needs to have a unique system wide
	  identity. Connection tracking zones allow to have multiple
	  connections using the same identity, as long as they are
	  contained in different zones.

	  If unsure, say `N'.

config NF_CONNTRACK_EVENTS
	bool "Connection tracking events"
	depends on NETFILTER_ADVANCED
	help
	  If this option is enabled, the connection tracking code will
	  provide a notifier chain that can be used by other kernel code
	  to get notified about changes in the connection tracking state.

	  If unsure, say `N'.

config NF_CT_PROTO_DCCP
	tristate 'DCCP protocol connection tracking support (EXPERIMENTAL)'
	depends on EXPERIMENTAL
	depends on NETFILTER_ADVANCED
	default IP_DCCP
	help
	  With this option enabled, the layer 3 independent connection
	  tracking code will be able to do state tracking on DCCP connections.

	  If unsure, say 'N'.

config NF_CT_PROTO_GRE
	tristate

config NF_CT_PROTO_SCTP
	tristate 'SCTP protocol connection tracking support (EXPERIMENTAL)'
	depends on EXPERIMENTAL
	depends on NETFILTER_ADVANCED
	default IP_SCTP
	help
	  With this option enabled, the layer 3 independent connection
	  tracking code will be able to do state tracking on SCTP connections.

	  If you want to compile it as a module, say M here and read
	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.

config NF_CT_PROTO_UDPLITE
	tristate 'UDP-Lite protocol connection tracking support'
	depends on NETFILTER_ADVANCED
	help
	  With this option enabled, the layer 3 independent connection
	  tracking code will be able to do state tracking on UDP-Lite
	  connections.

	  To compile it as a module, choose M here.  If unsure, say N.

config NF_CONNTRACK_AMANDA
	tristate "Amanda backup protocol support"
	depends on NETFILTER_ADVANCED
	select TEXTSEARCH
	select TEXTSEARCH_KMP
	help
	  If you are running the Amanda backup package <http://www.amanda.org/>
	  on this machine or machines that will be MASQUERADED through this
	  machine, then you may want to enable this feature.  This allows the
	  connection tracking and natting code to allow the sub-channels that
	  Amanda requires for communication of the backup data, messages and
	  index.

	  To compile it as a module, choose M here.  If unsure, say N.

config NF_CONNTRACK_FTP
	tristate "FTP protocol support"
	default m if NETFILTER_ADVANCED=n
	help
	  Tracking FTP connections is problematic: special helpers are
	  required for tracking them, and doing masquerading and other forms
	  of Network Address Translation on them.

	  This is FTP support on Layer 3 independent connection tracking.
	  Layer 3 independent connection tracking is experimental scheme
	  which generalize ip_conntrack to support other layer 3 protocols.

	  To compile it as a module, choose M here.  If unsure, say N.

config NF_CONNTRACK_H323
	tristate "H.323 protocol support"
	depends on (IPV6 || IPV6=n)
	depends on NETFILTER_ADVANCED
	help
	  H.323 is a VoIP signalling protocol from ITU-T. As one of the most
	  important VoIP protocols, it is widely used by voice hardware and
	  software including voice gateways, IP phones, Netmeeting, OpenPhone,
	  Gnomemeeting, etc.

	  With this module you can support H.323 on a connection tracking/NAT
	  firewall.

	  This module supports RAS, Fast Start, H.245 Tunnelling, Call
	  Forwarding, RTP/RTCP and T.120 based audio, video, fax, chat,
	  whiteboard, file transfer, etc. For more information, please
	  visit http://nath323.sourceforge.net/.

	  To compile it as a module, choose M here.  If unsure, say N.

config NF_CONNTRACK_IRC
	tristate "IRC protocol support"
	default m if NETFILTER_ADVANCED=n
	help
	  There is a commonly-used extension to IRC called
	  Direct Client-to-Client Protocol (DCC).  This enables users to send
	  files to each other, and also chat to each other without the need
	  of a server.  DCC Sending is used anywhere you send files over IRC,
	  and DCC Chat is most commonly used by Eggdrop bots.  If you are
	  using NAT, this extension will enable you to send files and initiate
	  chats.  Note that you do NOT need this extension to get files or
	  have others initiate chats, or everything else in IRC.

	  To compile it as a module, choose M here.  If unsure, say N.

config NF_CONNTRACK_NETBIOS_NS
	tristate "NetBIOS name service protocol support"
	depends on NETFILTER_ADVANCED
	help
	  NetBIOS name service requests are sent as broadcast messages from an
	  unprivileged port and responded to with unicast messages to the
	  same port. This make them hard to firewall properly because connection
	  tracking doesn't deal with broadcasts. This helper tracks locally
	  originating NetBIOS name service requests and the corresponding
	  responses. It relies on correct IP address configuration, specifically
	  netmask and broadcast address. When properly configured, the output
	  of "ip address show" should look similar to this:

	  $ ip -4 address show eth0
	  4: eth0: <BROADCAST,MULTICAST,UP> mtu 1500 qdisc pfifo_fast qlen 1000
	      inet 172.16.2.252/24 brd 172.16.2.255 scope global eth0

	  To compile it as a module, choose M here.  If unsure, say N.

config NF_CONNTRACK_PPTP
	tristate "PPtP protocol support"
	depends on NETFILTER_ADVANCED
	select NF_CT_PROTO_GRE
	help
	  This module adds support for PPTP (Point to Point Tunnelling
	  Protocol, RFC2637) connection tracking and NAT.

	  If you are running PPTP sessions over a stateful firewall or NAT
	  box, you may want to enable this feature.

	  Please note that not all PPTP modes of operation are supported yet.
	  Specifically these limitations exist:
	    - Blindly assumes that control connections are always established
	      in PNS->PAC direction. This is a violation of RFC2637.
	    - Only supports a single call within each session

	  To compile it as a module, choose M here.  If unsure, say N.

config NF_CONNTRACK_RTSP
        tristate  "RTSP protocol support"
        depends on NETFILTER_ADVANCED
        help
          Support the RTSP protocol.  This allows UDP transports to be setup
          properly, including RTP and RDT.

          If you want to compile it as a module, say 'M' here and read
          Documentation/modules.txt.  If unsure, say 'Y'.

config NF_CONNTRACK_SANE
	tristate "SANE protocol support (EXPERIMENTAL)"
	depends on EXPERIMENTAL
	depends on NETFILTER_ADVANCED
	help
	  SANE is a protocol for remote access to scanners as implemented
	  by the 'saned' daemon. Like FTP, it uses separate control and
	  data connections.

	  With this module you can support SANE on a connection tracking
	  firewall.

	  To compile it as a module, choose M here.  If unsure, say N.

config NF_CONNTRACK_SIP
	tristate "SIP protocol support"
	default m if NETFILTER_ADVANCED=n
	help
	  SIP is an application-layer control protocol that can establish,
	  modify, and terminate multimedia sessions (conferences) such as
	  Internet telephony calls. With the ip_conntrack_sip and
	  the nf_nat_sip modules you can support the protocol on a connection
	  tracking/NATing firewall.

	  To compile it as a module, choose M here.  If unsure, say N.

config NF_CONNTRACK_TFTP
	tristate "TFTP protocol support"
	depends on NETFILTER_ADVANCED
	help
	  TFTP connection tracking helper, this is required depending
	  on how restrictive your ruleset is.
	  If you are using a tftp client behind -j SNAT or -j MASQUERADING
	  you will need this.

	  To compile it as a module, choose M here.  If unsure, say N.

config NF_CT_NETLINK
	tristate 'Connection tracking netlink interface'
	select NETFILTER_NETLINK
	default m if NETFILTER_ADVANCED=n
	help
	  This option enables support for a netlink-based userspace interface

endif # NF_CONNTRACK

# transparent proxy support
config NETFILTER_TPROXY
	tristate "Transparent proxying support (EXPERIMENTAL)"
	depends on EXPERIMENTAL
	depends on IP_NF_MANGLE
	depends on NETFILTER_ADVANCED
	help
	  This option enables transparent proxying support, that is,
	  support for handling non-locally bound IPv4 TCP and UDP sockets.
	  For it to work you will have to configure certain iptables rules
	  and use policy routing. For more information on how to set it up
	  see Documentation/networking/tproxy.txt.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XTABLES
	tristate "Netfilter Xtables support (required for ip_tables)"
	default m if NETFILTER_ADVANCED=n
	help
	  This is required if you intend to use any of ip_tables,
	  ip6_tables or arp_tables.

if NETFILTER_XTABLES

comment "Xtables combined modules"

config NETFILTER_XT_MARK
	tristate 'nfmark target and match support'
	default m if NETFILTER_ADVANCED=n
	---help---
	This option adds the "MARK" target and "mark" match.

	Netfilter mark matching allows you to match packets based on the
	"nfmark" value in the packet.
	The target allows you to create rules in the "mangle" table which alter
	the netfilter mark (nfmark) field associated with the packet.

	Prior to routing, the nfmark can influence the routing method (see
	"Use netfilter MARK value as routing key") and can also be used by
	other subsystems to change their behavior.

config NETFILTER_XT_CONNMARK
	tristate 'ctmark target and match support'
	depends on NF_CONNTRACK
	depends on NETFILTER_ADVANCED
	select NF_CONNTRACK_MARK
	---help---
	This option adds the "CONNMARK" target and "connmark" match.

	Netfilter allows you to store a mark value per connection (a.k.a.
	ctmark), similarly to the packet mark (nfmark). Using this
	target and match, you can set and match on this mark.

config NETFILTER_XT_SET
	tristate 'set target and match support'
	depends on IP_SET
	depends on NETFILTER_ADVANCED
	help
	  This option adds the "SET" target and "set" match.

	  Using this target and match, you can add/delete and match
	  elements in the sets created by ipset(8).

	  To compile it as a module, choose M here.  If unsure, say N.

# alphabetically ordered list of targets

comment "Xtables targets"

config NETFILTER_XT_TARGET_CHECKSUM
	tristate "CHECKSUM target support"
	depends on IP_NF_MANGLE || IP6_NF_MANGLE
	depends on NETFILTER_ADVANCED
	---help---
	  This option adds a `CHECKSUM' target, which can be used in the iptables mangle
	  table.

	  You can use this target to compute and fill in the checksum in
	  a packet that lacks a checksum.  This is particularly useful,
	  if you need to work around old applications such as dhcp clients,
	  that do not work well with checksum offloads, but don't want to disable
	  checksum offload in your device.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_TARGET_CLASSIFY
	tristate '"CLASSIFY" target support'
	depends on NETFILTER_ADVANCED
	help
	  This option adds a `CLASSIFY' target, which enables the user to set
	  the priority of a packet. Some qdiscs can use this value for
	  classification, among these are:

  	  atm, cbq, dsmark, pfifo_fast, htb, prio

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_TARGET_CONNMARK
	tristate  '"CONNMARK" target support'
	depends on NF_CONNTRACK
	depends on NETFILTER_ADVANCED
	select NETFILTER_XT_CONNMARK
	---help---
	This is a backwards-compat option for the user's convenience
	(e.g. when running oldconfig). It selects
	CONFIG_NETFILTER_XT_CONNMARK (combined connmark/CONNMARK module).

config NETFILTER_XT_TARGET_CONNSECMARK
	tristate '"CONNSECMARK" target support'
	depends on NF_CONNTRACK && NF_CONNTRACK_SECMARK
	default m if NETFILTER_ADVANCED=n
	help
	  The CONNSECMARK target copies security markings from packets
	  to connections, and restores security markings from connections
	  to packets (if the packets are not already marked).  This would
	  normally be used in conjunction with the SECMARK target.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_TARGET_CT
	tristate '"CT" target support'
	depends on NF_CONNTRACK
	depends on IP_NF_RAW || IP6_NF_RAW
	depends on NETFILTER_ADVANCED
	help
	  This options adds a `CT' target, which allows to specify initial
	  connection tracking parameters like events to be delivered and
	  the helper to be used.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_TARGET_DSCP
	tristate '"DSCP" and "TOS" target support'
	depends on IP_NF_MANGLE || IP6_NF_MANGLE
	depends on NETFILTER_ADVANCED
	help
	  This option adds a `DSCP' target, which allows you to manipulate
	  the IPv4/IPv6 header DSCP field (differentiated services codepoint).

	  The DSCP field can have any value between 0x0 and 0x3f inclusive.

	  It also adds the "TOS" target, which allows you to create rules in
	  the "mangle" table which alter the Type Of Service field of an IPv4
	  or the Priority field of an IPv6 packet, prior to routing.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_TARGET_HL
	tristate '"HL" hoplimit target support'
	depends on IP_NF_MANGLE || IP6_NF_MANGLE
	depends on NETFILTER_ADVANCED
	---help---
	This option adds the "HL" (for IPv6) and "TTL" (for IPv4)
	targets, which enable the user to change the
	hoplimit/time-to-live value of the IP header.

	While it is safe to decrement the hoplimit/TTL value, the
	modules also allow to increment and set the hoplimit value of
	the header to arbitrary values. This is EXTREMELY DANGEROUS
	since you can easily create immortal packets that loop
	forever on the network.

config NETFILTER_XT_TARGET_IDLETIMER
	tristate  "IDLETIMER target support"
	depends on NETFILTER_ADVANCED
	help

	  This option adds the `IDLETIMER' target.  Each matching packet
	  resets the timer associated with label specified when the rule is
	  added.  When the timer expires, it triggers a sysfs notification.
	  The remaining time for expiration can be read via sysfs.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_TARGET_LED
	tristate '"LED" target support'
	depends on LEDS_CLASS && LEDS_TRIGGERS
	depends on NETFILTER_ADVANCED
	help
	  This option adds a `LED' target, which allows you to blink LEDs in
	  response to particular packets passing through your machine.

	  This can be used to turn a spare LED into a network activity LED,
	  which only flashes in response to FTP transfers, for example.  Or
	  you could have an LED which lights up for a minute or two every time
	  somebody connects to your machine via SSH.

	  You will need support for the "led" class to make this work.

	  To create an LED trigger for incoming SSH traffic:
	    iptables -A INPUT -p tcp --dport 22 -j LED --led-trigger-id ssh --led-delay 1000

	  Then attach the new trigger to an LED on your system:
	    echo netfilter-ssh > /sys/class/leds/<ledname>/trigger

	  For more information on the LEDs available on your system, see
	  Documentation/leds-class.txt

config NETFILTER_XT_TARGET_IMQ
        tristate '"IMQ" target support'
        depends on NETFILTER_XTABLES
        depends on IP_NF_MANGLE || IP6_NF_MANGLE
        select IMQ
        default m if NETFILTER_ADVANCED=n
        help
          This option adds a `IMQ' target which is used to specify if and
          to which imq device packets should get enqueued/dequeued.

          To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_TARGET_MARK
	tristate '"MARK" target support'
	depends on NETFILTER_ADVANCED
	select NETFILTER_XT_MARK
	---help---
	This is a backwards-compat option for the user's convenience
	(e.g. when running oldconfig). It selects
	CONFIG_NETFILTER_XT_MARK (combined mark/MARK module).

config NETFILTER_XT_TARGET_NFLOG
	tristate '"NFLOG" target support'
	default m if NETFILTER_ADVANCED=n
	select NETFILTER_NETLINK_LOG
	help
	  This option enables the NFLOG target, which allows to LOG
	  messages through nfnetlink_log.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_TARGET_NFQUEUE
	tristate '"NFQUEUE" target Support'
	depends on NETFILTER_ADVANCED
	help
	  This target replaced the old obsolete QUEUE target.

	  As opposed to QUEUE, it supports 65535 different queues,
	  not just one.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_TARGET_NOTRACK
	tristate  '"NOTRACK" target support'
	depends on IP_NF_RAW || IP6_NF_RAW
	depends on NF_CONNTRACK
	depends on NETFILTER_ADVANCED
	help
	  The NOTRACK target allows a select rule to specify
	  which packets *not* to enter the conntrack/NAT
	  subsystem with all the consequences (no ICMP error tracking,
	  no protocol helpers for the selected packets).

	  If you want to compile it as a module, say M here and read
	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.

config NETFILTER_XT_TARGET_RATEEST
	tristate '"RATEEST" target support'
	depends on NETFILTER_ADVANCED
	help
	  This option adds a `RATEEST' target, which allows to measure
	  rates similar to TC estimators. The `rateest' match can be
	  used to match on the measured rates.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_TARGET_TEE
	tristate '"TEE" - packet cloning to alternate destination'
	depends on NETFILTER_ADVANCED
	depends on (IPV6 || IPV6=n)
	depends on !NF_CONNTRACK || NF_CONNTRACK
	---help---
	This option adds a "TEE" target with which a packet can be cloned and
	this clone be rerouted to another nexthop.

config NETFILTER_XT_TARGET_TPROXY
	tristate '"TPROXY" target support (EXPERIMENTAL)'
	depends on EXPERIMENTAL
	depends on NETFILTER_TPROXY
	depends on NETFILTER_XTABLES
	depends on NETFILTER_ADVANCED
	select NF_DEFRAG_IPV4
	default m
	help
	  This option adds a `TPROXY' target, which is somewhat similar to
	  REDIRECT.  It can only be used in the mangle table and is useful
	  to redirect traffic to a transparent proxy.  It does _not_ depend
	  on Netfilter connection tracking and NAT, unlike REDIRECT.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_TARGET_TRACE
	tristate  '"TRACE" target support'
	depends on IP_NF_RAW || IP6_NF_RAW
	depends on NETFILTER_ADVANCED
	help
	  The TRACE target allows you to mark packets so that the kernel
	  will log every rule which match the packets as those traverse
	  the tables, chains, rules.

	  If you want to compile it as a module, say M here and read
	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.

config NETFILTER_XT_TARGET_SECMARK
	tristate '"SECMARK" target support'
	depends on NETWORK_SECMARK
	default m if NETFILTER_ADVANCED=n
	help
	  The SECMARK target allows security marking of network
	  packets, for use with security subsystems.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_TARGET_ACCOUNT
	tristate '"ACCOUNT" target support'
	depends on NETFILTER_XTABLES
	---help---
	  The ACCOUNT target is a high performance accounting system for large
	  local networks. It allows per-IP accounting in whole prefixes of IPv4
	  addresses with size of up to /8 without the need to add individual
	  accouting rule for each IP address.

	  The ACCOUNT is designed to be queried for data every second or at
	  least every ten seconds. It is written as kernel module to handle high
	  bandwidths without packet loss.

	  The largest possible subnet size is 24 bit, meaning for example 10.0.0.0/8
	  network. ACCOUNT uses fixed internal data structures
	  which speeds up the processing of each packet. Furthermore,
	  accounting data for one complete 192.168.1.X/24 network takes 4 KB of
	  memory. Memory for 16 or 24 bit networks is only allocated when
	  needed.

	  To optimize the kernel<->userspace data transfer a bit more, the
	  kernel module only transfers information about IPs, where the src/dst
	  packet counter is not 0. This saves precious kernel time.

	  There is no /proc interface as it would be too slow for continuous access.
	  The read-and-flush query operation is the fastest, as no internal data
	  snapshot needs to be created&copied for all data. Use the "read"
	  operation without flush only for debugging purposes!

	  Usage:

	  ACCOUNT takes two mandatory parameters:

	  --addr network/netmask
	  where network/netmask is the subnet to account for, in CIDR syntax

	  --tname NAME
	  where NAME is the name of the table where the accounting information
	  should be stored

	  The subnet 0.0.0.0/0 is a special case: all data are then stored in the src_bytes
	  and src_packets structure of slot "0". This is useful if you want
	  to account the overall traffic to/from your internet provider.

	  The data can be queried using the userspace libxt_ACCOUNT_cl library,
	  and by the reference implementation to show usage of this library,
	  the iptaccount(8) tool.

	  Here is an example of use:

	  iptables -A FORWARD -j ACCOUNT --addr 0.0.0.0/0 --tname all_outgoing;
	  iptables -A FORWARD -j ACCOUNT --addr 192.168.1.0/24 --tname sales;

	  This creates two tables called "all_outgoing" and "sales" which can be
	  queried using the userspace library/iptaccount tool.

	  Note that this target is non-terminating, the packet destined to it
	  will continue traversing the chain in which it has been used.

	  Also note that once a table has been defined for specific CIDR address/netmask
	  block, it can be referenced multiple times using -j ACCOUNT, provided
	  that both the original table name and address/netmask block are specified.

	  For more information go to http://www.intra2net.com/en/developer/ipt_ACCOUNT/

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_TARGET_CHAOS
	tristate '"CHAOS" target support'
	depends on NETFILTER_XTABLES
	---help---
	  Causes confusion on the other end by doing odd things with incoming packets.
	  CHAOS will randomly reply (or not) with one of its configurable subtargets:

	  --delude
	  Use the REJECT and DELUDE targets as a base to do a sudden or deferred
	  connection reset, fooling some network scanners to return non-deterministic
	  (randomly open/closed) results, and in case it is deemed open, it is actually
	  closed/filtered.

	  --tarpit
	  Use the REJECT and TARPIT target as a base to hold the connection until it
	  times out. This consumes conntrack entries when connection tracking is loaded
	  (which usually is on most machines), and routers inbetween you and the Internet
	  may fail to do their connection tracking if they have to handle more
	  connections than they can.

	  The randomness factor of not replying vs. replying can be set during load-time
	  of the xt_CHAOS module or during runtime in /sys/modules/xt_CHAOS/parameters.

	  See http://jengelh.medozas.de/projects/chaostables/ for more information
	  about CHAOS, DELUDE and lscan.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_TARGET_DELUDE
	tristate '"DELUDE" target support'
	depends on NETFILTER_XTABLES
	---help---
	  The DELUDE target will reply to a SYN packet with SYN-ACK, and to all other
	  packets with an RST. This will terminate the connection much like REJECT, but
	  network scanners doing TCP half-open discovery can be spoofed to make them
	  belive the port is open rather than closed/filtered.

	  To compile it as a module, choose M here.  If unsure, say N.  

config NETFILTER_XT_TARGET_ECHO
	tristate '"ECHO" target support'
	depends on NETFILTER_XTABLES
	---help---
	  The ECHO target will send back all packets it received. It serves as an
	  examples for an Xtables target.

	  To compile it as a module, choose M here.  If unsure, say N.  

config NETFILTER_XT_TARGET_RAWNAT
	tristate '"RAWNAT" target support'
	depends on NETFILTER_XTABLES
	---help---
	  The RAWSNAT and RAWDNAT targets provide stateless network address
	  translation.

	  The RAWDNAT target will rewrite the destination address in the IP header,
	  much like the NETMAP target.

	  --to-destination addr[/mask]
	  Network address to map to. The resulting address will be constructed the
	  following way: All 'one' bits in the mask are filled in from the new
	  address. All bits that are zero in the mask are filled in from the
	  original address.

	  The RAWSNAT target will rewrite the source address in the IP header, much
	  like the NETMAP target. RAWSNAT (and RAWDNAT) may only be
	  used in the raw or rawpost tables, but can be used in all chains,
	  which makes it possible to change the source address either when the packet
	  enters the machine or when it leaves it. The reason for this table constraint
	  is that RAWNAT must happen outside of connection tracking.

	  --to-source addr[/mask]
	  Network address to map to. The resulting address will be constructed the
	  following way: All 'one' bits in the mask are filled in from the new
	  address. All bits that are zero in the mask are filled in from the
	  original address.

	  As an example, changing the destination for packets forwarded from an internal
	  LAN to the internet:

	  -t raw -A PREROUTING -i lan0 -d 212.201.100.135 -j RAWDNAT --to-destination 199.181.132.250;
	  -t rawpost -A POSTROUTING -o lan0 -s 199.181.132.250 -j RAWSNAT --to-source 212.201.100.135;

	  Note that changing addresses may influence the route selection! Specifically,
	  it statically NATs packets, not connections, like the normal DNAT/SNAT targets
	  would do. Also note that it can transform already-NATed connections, as
	  said, it is completely external to Netfilter's connection tracking/NAT.

	  If the machine itself generates packets that are to be rawnat'ed, you need a
	  rule in the OUTPUT chain instead, just like you would with the stateful NAT
	  targets.

	  It may be necessary that in doing so, you also need an extra RAWSNAT rule, to
	  override the automatic source address selection that the routing code does
	  before passing packets to iptables. If the connecting socket has not been
	  explicitly bound to an address, as is the common mode of operation, the address
	  that will be chosen is the primary address of the device through which the
	  packet would be routed with its initial destination address - the address as
	  seen before any RAWNAT takes place.

	  To compile it as a module, choose M here.  If unsure, say N.  

config NETFILTER_XT_TARGET_STEAL
	tristate '"STEAL" target support'
	depends on NETFILTER_XTABLES
	---help---
	  Like the DROP target, but does not throw an error like DROP when used in the
	  OUTPUT chain.

	  To compile it as a module, choose M here.  If unsure, say N.  
	  
config NETFILTER_XT_TARGET_TARPIT
	tristate '"TARPIT" target support'
	depends on NETFILTER_XTABLES
	---help---
	  Adds a TARPIT target to iptables, which captures and holds
	  incoming TCP connections using no local per-connection resources.
	  Connections are accepted, but immediately switched to the persist
	  state (0 byte window), in which the remote side stops sending data
	  and asks to continue every 60-240 seconds. Attempts to close the
	  connection are ignored, forcing the remote side to time out the
	  connection in 12-24 minutes.

	  This offers similar functionality to LaBrea
	  <http://www.hackbusters.net/LaBrea/>, but does not require dedicated
	  hardware or IPs. Any TCP port that you would normally DROP or REJECT
	  can instead become a tarpit.

	  To compile it as a module, choose M here.  If unsure, say N.
  
config NETFILTER_XT_TARGET_TCPMSS
	tristate '"TCPMSS" target support'
	depends on (IPV6 || IPV6=n)
	default m if NETFILTER_ADVANCED=n
	---help---
	  This option adds a `TCPMSS' target, which allows you to alter the
	  MSS value of TCP SYN packets, to control the maximum size for that
	  connection (usually limiting it to your outgoing interface's MTU
	  minus 40).

	  This is used to overcome criminally braindead ISPs or servers which
	  block ICMP Fragmentation Needed packets.  The symptoms of this
	  problem are that everything works fine from your Linux
	  firewall/router, but machines behind it can never exchange large
	  packets:
	        1) Web browsers connect, then hang with no data received.
	        2) Small mail works fine, but large emails hang.
	        3) ssh works fine, but scp hangs after initial handshaking.

	  Workaround: activate this option and add a rule to your firewall
	  configuration like:

	  iptables -A FORWARD -p tcp --tcp-flags SYN,RST SYN \
	                 -j TCPMSS --clamp-mss-to-pmtu

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_TARGET_TCPOPTSTRIP
	tristate '"TCPOPTSTRIP" target support (EXPERIMENTAL)'
	depends on EXPERIMENTAL
	depends on IP_NF_MANGLE || IP6_NF_MANGLE
	depends on NETFILTER_ADVANCED
	help
	  This option adds a "TCPOPTSTRIP" target, which allows you to strip
	  TCP options from TCP packets.

# alphabetically ordered list of matches

comment "Xtables matches"

config NETFILTER_XT_MATCH_CLUSTER
	tristate '"cluster" match support'
	depends on NF_CONNTRACK
	depends on NETFILTER_ADVANCED
	---help---
	  This option allows you to build work-load-sharing clusters of
	  network servers/stateful firewalls without having a dedicated
	  load-balancing router/server/switch. Basically, this match returns
	  true when the packet must be handled by this cluster node. Thus,
	  all nodes see all packets and this match decides which node handles
	  what packets. The work-load sharing algorithm is based on source
	  address hashing.

	  If you say Y or M here, try `iptables -m cluster --help` for
	  more information.

config NETFILTER_XT_MATCH_COMMENT
	tristate  '"comment" match support'
	depends on NETFILTER_ADVANCED
	help
	  This option adds a `comment' dummy-match, which allows you to put
	  comments in your iptables ruleset.

	  If you want to compile it as a module, say M here and read
	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.

config NETFILTER_XT_MATCH_CONNBYTES
	tristate  '"connbytes" per-connection counter match support'
	depends on NF_CONNTRACK
	depends on NETFILTER_ADVANCED
	help
	  This option adds a `connbytes' match, which allows you to match the
	  number of bytes and/or packets for each direction within a connection.

	  If you want to compile it as a module, say M here and read
	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.

config NETFILTER_XT_MATCH_CONNLIMIT
	tristate '"connlimit" match support"'
	depends on NF_CONNTRACK
	depends on NETFILTER_ADVANCED
	---help---
	  This match allows you to match against the number of parallel
	  connections to a server per client IP address (or address block).

config NETFILTER_XT_MATCH_CONNMARK
	tristate  '"connmark" connection mark match support'
	depends on NF_CONNTRACK
	depends on NETFILTER_ADVANCED
	select NETFILTER_XT_CONNMARK
	---help---
	This is a backwards-compat option for the user's convenience
	(e.g. when running oldconfig). It selects
	CONFIG_NETFILTER_XT_CONNMARK (combined connmark/CONNMARK module).

config NETFILTER_XT_MATCH_CONNTRACK
	tristate '"conntrack" connection tracking match support'
	depends on NF_CONNTRACK
	default m if NETFILTER_ADVANCED=n
	help
	  This is a general conntrack match module, a superset of the state match.

	  It allows matching on additional conntrack information, which is
	  useful in complex configurations, such as NAT gateways with multiple
	  internet links or tunnels.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_CPU
	tristate '"cpu" match support'
	depends on NETFILTER_ADVANCED
	help
	  CPU matching allows you to match packets based on the CPU
	  currently handling the packet.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_DCCP
	tristate '"dccp" protocol match support'
	depends on NETFILTER_ADVANCED
	default IP_DCCP
	help
	  With this option enabled, you will be able to use the iptables
	  `dccp' match in order to match on DCCP source/destination ports
	  and DCCP flags.

	  If you want to compile it as a module, say M here and read
	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.

config NETFILTER_XT_MATCH_DSCP
	tristate '"dscp" and "tos" match support'
	depends on NETFILTER_ADVANCED
	help
	  This option adds a `DSCP' match, which allows you to match against
	  the IPv4/IPv6 header DSCP field (differentiated services codepoint).

	  The DSCP field can have any value between 0x0 and 0x3f inclusive.

	  It will also add a "tos" match, which allows you to match packets
	  based on the Type Of Service fields of the IPv4 packet (which share
	  the same bits as DSCP).

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_ESP
	tristate '"esp" match support'
	depends on NETFILTER_ADVANCED
	help
	  This match extension allows you to match a range of SPIs
	  inside ESP header of IPSec packets.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_HASHLIMIT
	tristate '"hashlimit" match support'
	depends on (IP6_NF_IPTABLES || IP6_NF_IPTABLES=n)
	depends on NETFILTER_ADVANCED
	help
	  This option adds a `hashlimit' match.

	  As opposed to `limit', this match dynamically creates a hash table
	  of limit buckets, based on your selection of source/destination
	  addresses and/or ports.

	  It enables you to express policies like `10kpps for any given
	  destination address' or `500pps from any given source address'
	  with a single rule.

config NETFILTER_XT_MATCH_HELPER
	tristate '"helper" match support'
	depends on NF_CONNTRACK
	depends on NETFILTER_ADVANCED
	help
	  Helper matching allows you to match packets in dynamic connections
	  tracked by a conntrack-helper, ie. ip_conntrack_ftp

	  To compile it as a module, choose M here.  If unsure, say Y.

config NETFILTER_XT_MATCH_HL
	tristate '"hl" hoplimit/TTL match support'
	depends on NETFILTER_ADVANCED
	---help---
	HL matching allows you to match packets based on the hoplimit
	in the IPv6 header, or the time-to-live field in the IPv4
	header of the packet.

config NETFILTER_XT_MATCH_IPRANGE
	tristate '"iprange" address range match support'
	depends on NETFILTER_ADVANCED
	---help---
	This option adds a "iprange" match, which allows you to match based on
	an IP address range. (Normal iptables only matches on single addresses
	with an optional mask.)

	If unsure, say M.

config NETFILTER_XT_MATCH_IPVS
	tristate '"ipvs" match support'
	depends on IP_VS
	depends on NETFILTER_ADVANCED
	depends on NF_CONNTRACK
	help
	  This option allows you to match against IPVS properties of a packet.

	  If unsure, say N.

config NETFILTER_XT_MATCH_LENGTH
	tristate '"length" match support'
	depends on NETFILTER_ADVANCED
	help
	  This option allows you to match the length of a packet against a
	  specific value or range of values.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_LIMIT
	tristate '"limit" match support'
	depends on NETFILTER_ADVANCED
	help
	  limit matching allows you to control the rate at which a rule can be
	  matched: mainly useful in combination with the LOG target ("LOG
	  target support", below) and to avoid some Denial of Service attacks.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_MAC
	tristate '"mac" address match support'
	depends on NETFILTER_ADVANCED
	help
	  MAC matching allows you to match packets based on the source
	  Ethernet address of the packet.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_MARK
	tristate '"mark" match support'
	depends on NETFILTER_ADVANCED
	select NETFILTER_XT_MARK
	---help---
	This is a backwards-compat option for the user's convenience
	(e.g. when running oldconfig). It selects
	CONFIG_NETFILTER_XT_MARK (combined mark/MARK module).

config NETFILTER_XT_MATCH_MULTIPORT
	tristate '"multiport" Multiple port match support'
	depends on NETFILTER_ADVANCED
	help
	  Multiport matching allows you to match TCP or UDP packets based on
	  a series of source or destination ports: normally a rule can only
	  match a single range of ports.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_OSF
	tristate '"osf" Passive OS fingerprint match'
	depends on NETFILTER_ADVANCED && NETFILTER_NETLINK
	help
	  This option selects the Passive OS Fingerprinting match module
	  that allows to passively match the remote operating system by
	  analyzing incoming TCP SYN packets.

	  Rules and loading software can be downloaded from
	  http://www.ioremap.net/projects/osf

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_OWNER
	tristate '"owner" match support'
	depends on NETFILTER_ADVANCED
	---help---
	Socket owner matching allows you to match locally-generated packets
	based on who created the socket: the user or group. It is also
	possible to check whether a socket actually exists.

config NETFILTER_XT_MATCH_POLICY
	tristate 'IPsec "policy" match support'
	depends on XFRM
	default m if NETFILTER_ADVANCED=n
	help
	  Policy matching allows you to match packets based on the
	  IPsec policy that was used during decapsulation/will
	  be used during encapsulation.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_PHYSDEV
	tristate '"physdev" match support'
	depends on BRIDGE && BRIDGE_NETFILTER
	depends on NETFILTER_ADVANCED
	help
	  Physdev packet matching matches against the physical bridge ports
	  the IP packet arrived on or will leave by.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_PKTTYPE
	tristate '"pkttype" packet type match support'
	depends on NETFILTER_ADVANCED
	help
	  Packet type matching allows you to match a packet by
	  its "class", eg. BROADCAST, MULTICAST, ...

	  Typical usage:
	  iptables -A INPUT -m pkttype --pkt-type broadcast -j LOG

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_QUOTA
	tristate '"quota" match support'
	depends on NETFILTER_ADVANCED
	help
	  This option adds a `quota' match, which allows to match on a
	  byte counter.

	  If you want to compile it as a module, say M here and read
	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.

config NETFILTER_XT_MATCH_RATEEST
	tristate '"rateest" match support'
	depends on NETFILTER_ADVANCED
	select NETFILTER_XT_TARGET_RATEEST
	help
	  This option adds a `rateest' match, which allows to match on the
	  rate estimated by the RATEEST target.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_REALM
	tristate  '"realm" match support'
	depends on NETFILTER_ADVANCED
	select NET_CLS_ROUTE
	help
	  This option adds a `realm' match, which allows you to use the realm
	  key from the routing subsystem inside iptables.

	  This match pretty much resembles the CONFIG_NET_CLS_ROUTE4 option 
	  in tc world.

	  If you want to compile it as a module, say M here and read
	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.

config NETFILTER_XT_MATCH_RECENT
	tristate '"recent" match support'
	depends on NETFILTER_ADVANCED
	---help---
	This match is used for creating one or many lists of recently
	used addresses and then matching against that/those list(s).

	Short options are available by using 'iptables -m recent -h'
	Official Website: <http://snowman.net/projects/ipt_recent/>

config NETFILTER_XT_MATCH_SCTP
	tristate  '"sctp" protocol match support (EXPERIMENTAL)'
	depends on EXPERIMENTAL
	depends on NETFILTER_ADVANCED
	default IP_SCTP
	help
	  With this option enabled, you will be able to use the 
	  `sctp' match in order to match on SCTP source/destination ports
	  and SCTP chunk types.

	  If you want to compile it as a module, say M here and read
	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.

config NETFILTER_XT_MATCH_SOCKET
	tristate '"socket" match support (EXPERIMENTAL)'
	depends on EXPERIMENTAL
	depends on NETFILTER_TPROXY
	depends on NETFILTER_XTABLES
	depends on NETFILTER_ADVANCED
	depends on !NF_CONNTRACK || NF_CONNTRACK
	select NF_DEFRAG_IPV4
	help
	  This option adds a `socket' match, which can be used to match
	  packets for which a TCP or UDP socket lookup finds a valid socket.
	  It can be used in combination with the MARK target and policy
	  routing to implement full featured non-locally bound sockets.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_STATE
	tristate '"state" match support'
	depends on NF_CONNTRACK
	default m if NETFILTER_ADVANCED=n
	help
	  Connection state matching allows you to match packets based on their
	  relationship to a tracked connection (ie. previous packets).  This
	  is a powerful tool for packet classification.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_LAYER7
        tristate '"layer7" match support'
        depends on NETFILTER_XTABLES
        depends on IP_NF_CONNTRACK || NF_CONNTRACK
        help
          Say Y if you want to be able to classify connections (and their
          packets) based on regular expression matching of their application
          layer data.   This is one way to classify applications such as
          peer-to-peer filesharing systems that do not always use the same
          port.

          To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_LAYER7_DEBUG
        bool 'layer7 debugging output'
        depends on NETFILTER_XT_MATCH_LAYER7
        help
          Say Y to get lots of debugging output.

config NETFILTER_XT_MATCH_STATISTIC
	tristate '"statistic" match support'
	depends on NETFILTER_ADVANCED
	help
	  This option adds a `statistic' match, which allows you to match
	  on packets periodically or randomly with a given percentage.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_STRING
	tristate  '"string" match support'
	depends on NETFILTER_ADVANCED
	select TEXTSEARCH
	select TEXTSEARCH_KMP
	select TEXTSEARCH_BM
	select TEXTSEARCH_FSM
	help
	  This option adds a `string' match, which allows you to look for
	  pattern matchings in packets.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_TCPMSS
	tristate '"tcpmss" match support'
	depends on NETFILTER_ADVANCED
	help
	  This option adds a `tcpmss' match, which allows you to examine the
	  MSS value of TCP SYN packets, which control the maximum packet size
	  for that connection.

	  To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_TIME
	tristate '"time" match support'
	depends on NETFILTER_ADVANCED
	---help---
	  This option adds a "time" match, which allows you to match based on
	  the packet arrival time (at the machine which netfilter is running)
	  on) or departure time/date (for locally generated packets).

	  If you say Y here, try `iptables -m time --help` for
	  more information.

	  If you want to compile it as a module, say M here.
	  If unsure, say N.

config NETFILTER_XT_MATCH_U32
	tristate '"u32" match support'
	depends on NETFILTER_ADVANCED
	---help---
	  u32 allows you to extract quantities of up to 4 bytes from a packet,
	  AND them with specified masks, shift them by specified amounts and
	  test whether the results are in any of a set of specified ranges.
	  The specification of what to extract is general enough to skip over
	  headers with lengths stored in the packet, as in IP or TCP header
	  lengths.

	  Details and examples are in the kernel module source.

config NETFILTER_XT_MATCH_WEBSTR
        tristate  '"webstr" match support'
        depends on NETFILTER_XTABLES
        help
          This option adds a `webstr' match, which allows you to look for
          pattern matchings in http stream.

          To compile it as a module, choose M here.  If unsure, say N.

config NETFILTER_XT_MATCH_CONDITION
        tristate  '"condition" match support'
        depends on NETFILTER_XTABLES
        help
          This option allows you to match firewall rules against condition
          variables stored in the /proc/net/nf_condition directory.

          N.B.: older versions used /proc/net/ipt_condition. You can
          reenable it with "compat_dir_name".

          If you want to compile it as a module, say M here and read
          Documentation/modules.txt.  If unsure, say `N'.

config NETFILTER_XT_MATCH_GEOIP
   tristate  '"geoip" match support'
   depends on NETFILTER_XTABLES
   help
          This option allows you to match a packet by its source or
          destination country.  Basically, you need a country's
          database containing all subnets and associated countries.

          For the complete procedure and understanding, read :
          http://people.netfilter.org/acidfu/geoip/howto/geoip-HOWTO.html

          If you want to compile it as a module, say M here and read
          <file:Documentation/modules.txt>.  The module will be
          called `ipt_geoip'.  If unsure, say `N'.

config NETFILTER_XT_MATCH_FUZZY
	tristate '"MATCH" match support'
	depends on NETFILTER_XTABLES
	---help---
	  This module matches a rate limit based on a fuzzy logic controller (FLC).

	  --lower-limit number
	  Specifies the lower limit, in packets per second.

	  --upper-limit number
	  Specifies the upper limit, also in packets per second.

	  To compile it as a module, choose M here.  If unsure, say N.  

config NETFILTER_XT_MATCH_IFACE
	tristate '"IFACE" target support'
	depends on NETFILTER_XTABLES
	---help---
	  Allows you to check interface states. First, an interface needs to be selected
	  for comparison. Exactly one option of the following three must be specified:

	  --iface name
	  Check the states on the given interface.

	  --dev-in
	  Check the states on the interface on which the packet came in. If the input
	  device is not set, because for example you are using -m iface in the OUTPUT
	  chain, this submatch returns false.

	  --dev-out
	  Check the states on the interface on which the packet will go out. If the
	  output device is not set, because for example you are using -m iface in the
	  INPUT chain, this submatch returns false.

	  Following that, one can select the interface properties to check for:

	  [!] --up, [!] --down
	  Check the UP flag.

	  [!] --broadcast
	  Check the BROADCAST flag.

	  [!] --loopback
	  Check the LOOPBACK flag.

	  [!] --pointtopoint
	  Check the POINTTOPOINT flag.

	  [!] --running
	  Check the RUNNING flag. Do NOT rely on it!

	  [!] --noarp, [!] --arp
	  Check the NOARP flag.

	  [!] --promisc
	  Check the PROMISC flag.

	  [!] --multicast
	  Check the MULTICAST flag.

	  [!] --dynamic
	  Check the DYNAMIC flag.

	  [!] --lower-up
	  Check the LOWER_UP flag.

	  [!] --dormant
	  Check the DORMANT flag.

	  To compile it as a module, choose M here.  If unsure, say N.  

config NETFILTER_XT_MATCH_IPV4OPTIONS
	tristate '"IPV4OPTIONS" match support'
	depends on NETFILTER_XTABLES
	---help---
	  The "ipv4options" module allows to match against a set of IPv4 header options.

	  --flags [!]symbol[,[!]symbol...]
	  Specify the options that shall appear or not appear in the header. Each
	  symbol specification is delimited by a comma, and a '!' can be prefixed to
	  a symbol to negate its presence. Symbols are either the name of an IPv4 option
	  or its number. See examples below.

	  --any
	  By default, all of the flags specified must be present/absent, that is, they
	  form an AND condition. Use the --any flag instead to use an OR condition
	  where only at least one symbol spec must be true.

	  Known symbol names (and their number):

	  1 nop
	  2 security RFC 1108
	  3 lsrr Loose Source Routing, RFC 791
	  4 timestamp RFC 781, 791
	  7 record-route RFC 791
	  9 ssrr Strict Source Routing, RFC 791
	  11 mtu-probe RFC 1063
	  12 mtu-reply RFC 1063
	  18 traceroute RFC 1393
	  20 router-alert RFC 2113

	  Examples:

	  Match packets that have both Timestamp and NOP:
	  -m ipv4options --flags nop,timestamp

	  ~ that have either of Timestamp or NOP, or both:
	  --flags nop,timestamp --any

	  ~ that have Timestamp and no NOP: --flags '!nop,timestamp'

	  ~ that have either no NOP or a timestamp (or both conditions):
	  --flags '!nop,timestamp' --any

	  To compile it as a module, choose M here.  If unsure, say N.  

config NETFILTER_XT_MATCH_LSCAN
	tristate '"LSCAN" match support'
	depends on NETFILTER_XTABLES
	---help---
	  Detects simple low-level scan attemps based upon the packet's contents.
	  (This is different from other implementations, which also try to match the rate of new
	  connections.) Note that an attempt is only discovered after it has been carried
	  out, but this information can be used in conjunction with other rules to block
	  the remote host's future connections. So this match module will match on the
	  (probably) last packet the remote side will send to your machine.

	  --stealth
	  Match if the packet did not belong to any known TCP connection
	  (Stealth/FIN/XMAS/NULL scan).

	  --synscan
	  Match if the connection was a TCP half-open discovery (SYN scan), i.e. the
	  connection was torn down after the 2nd packet in the 3-way handshake.

	  --cnscan
	  Match if the connection was a TCP full open discovery (connect scan), i.e. the
	  connection was torn down after completion of the 3-way handshake.

	  --grscan
	  Match if data in the connection only flew in the direction of the remote side,
	  e.g. if the connection was terminated after a locally running daemon sent its
	  identification. (E.g. openssh, smtp, ftpd.) This may falsely trigger on
	  warranted single-direction data flows, usually bulk data transfers such as
	  FTP DATA connections or IRC DCC. Grab Scan Detection should only be used on
	  ports where a protocol runs that is guaranteed to do a bidirectional exchange
	  of bytes.

	  NOTE: Some clients (Windows XP for example) may do what looks like a SYN scan,
	  so be advised to carefully use xt_lscan in conjunction with blocking rules,
	  as it may lock out your very own internal network.

	  To compile it as a module, choose M here.  If unsure, say N.  
	  
config NETFILTER_XT_MATCH_PKNOCK
	tristate '"PKNOCK" match support'
	depends on NETFILTER_XTABLES
	---help---
	  Pknock match implements so-called "port knocking", a stealthy system
	  for network authentication: a client sends packets to selected
	  ports in a specific sequence (= simple mode, see example 1 below), or a HMAC
	  payload to a single port (= complex mode, see example 2 below),
	  to a target machine that has pknock rule(s) installed. The target machine
	  then decides whether to unblock or block (again) the pknock-protected port(s).
	  This can be used, for instance, to avoid brute force
	  attacks on ssh or ftp services.

	  Example prerequisites:

	  modprobe cn

	  modprobe xt_pknock

	  Example 1 (TCP mode, manual closing of opened port not possible):

	  iptables -P INPUT DROP

	  iptables -A INPUT -p tcp -m pknock --knockports 4002,4001,4004 --strict
	  --name SSH --time 10 --autoclose 60 --dport 22 -j ACCEPT

	  The rule will allow tcp port 22 for the attempting IP address after the successful reception of TCP SYN packets
	  to ports 4002, 4001 and 4004, in this order (a.k.a. port-knocking).
	  Port numbers in the connect sequence must follow the exact specification, no
	  other ports may be "knocked" inbetween. The rule is named 'SSH', a file of
	  the same name for tracking port knocking states will be created in
	  /proc/net/xt_pknock .
	  Successive port knocks must occur with delay of at most 10 seconds. Port 22 (from the example) will
	  be automatiaclly dropped after 60 minutes after it was previously allowed.

	  Example 2 (UDP mode, non-replayable and non-spoofable, manual closing
	  of opened port possible, secure, also called "SPA" = Secure Port
	  Authorization):

	  iptables -A INPUT -p udp -m pknock --knockports 4000 --name FTP
	  --opensecret foo --closesecret bar --autoclose 240 -j DROP

	  iptables -A INPUT -p tcp -m pknock --checkip --name FTP --dport 21 -j ACCEPT

	  The first rule will create an "ALLOWED" record in /proc/net/xt_pknock/FTP after
	  the successful reception of an UDP packet to port 4000. The packet payload must be
	  constructed as a HMAC256 using "foo" as a key. The HMAC content is the particular 
	  client's IP address as a 32-bit network byteorder quantity,
	  plus the number of minutes since the Unix epoch, also as a 32-bit value.
	  (This is known as Simple Packet Authorization, also called "SPA".)
	  In such case, any subsequent attempt to connect to port 21 from the client's IP
	  address will cause such packets to be accepted in the second rule.

	  Similarly, upon reception of an UDP packet constructed the same way, but with
	  the key "bar", the first rule will remove a previously installed "ALLOWED" state
	  record from /proc/net/xt_pknock/FTP, which means that the second rule will
	  stop matching for subsequent connection attempts to port 21.
	  In case no close-secret packet is received within 4 hours, the first rule
	  will remove "ALLOWED" record from /proc/net/xt_pknock/FTP itself.

	  Things worth noting:

	  General:

	  Specifying --autoclose 0 means that no automatic close will be performed at all.

	  xt_pknock is capable of sending information about successful matches
	  via a netlink socket to userspace, should you need to implement your own
	  way of receiving and handling portknock notifications.
	  Be sure to read the documentation in the doc/pknock/ directory,
	  or visit the original site, http://portknocko.berlios.de/ .

	  TCP mode:

	  This mode is not immune against eavesdropping, spoofing and
	  replaying of the port knock sequence by someone else (but its use may still
	  be sufficient for scenarios where these factors are not necessarily
	  this important, such as bare shielding of the SSH port from brute-force attacks).
	  However, if you need these features, you should use UDP mode.

	  It is always wise to specify three or more ports that are not monotonically
	  increasing or decreasing with a small stepsize (e.g. 1024,1025,1026)
	  to avoid accidentally triggering
	  the rule by a portscan.

	  Specifying the inter-knock timeout with --time is mandatory in TCP mode,
	  to avoid permanent denial of services by clogging up the peer knock-state tracking table
	  that xt_pknock internally keeps, should there be a DDoS on the
	  first-in-row knock port from more hostile IP addresses than what the actual size
	  of this table is (defaults to 16, can be changed via the "peer_hasht_ents" module parameter).
	  It is also wise to use as short a time as possible (1 second) for --time
	  for this very reason. You may also consider increasing the size
	  of the peer knock-state tracking table. Using --strict also helps,
	  as it requires the knock sequence to be exact. This means that if the
	  hostile client sends more knocks to the same port, xt_pknock will
	  mark such attempt as failed knock sequence and will forget it immediately.
	  To completely thwart this kind of DDoS, knock-ports would need to have
	  an additional rate-limit protection. Or you may consider using UDP mode.

	  UDP mode:

	  This mode is immune against eavesdropping, replaying and spoofing attacks.
	  It is also immune against DDoS attack on the knockport.

	  For this mode to work, the clock difference on the client and on the server
	  must be below 1 minute. Synchronizing time on both ends by means
	  of NTP or rdate is strongly suggested.

	  There is a rate limiter built into xt_pknock which blocks any subsequent
	  open attempt in UDP mode should the request arrive within less than one
	  minute since the first successful open. This is intentional;
	  it thwarts eventual spoofing attacks.

	  Because the payload value of an UDP knock packet is influenced by client's IP address,
	  UDP mode cannot be used across NAT.

	  For sending UDP "SPA" packets, you may use either knock.sh or
	  knock-orig.sh. These may be found in doc/pknock/util.

	  To compile it as a module, choose M here.  If unsure, say N.  

config NETFILTER_XT_MATCH_PSD
	tristate '"PSD" match support'
	depends on NETFILTER_XTABLES
	---help---
	  Attempt to detect TCP and UDP port scans. This match was derived from
	  Solar Designer's scanlogd.

	  --psd-weight-threshold threshold
	  Total weight of the latest TCP/UDP packets with different
	  destination ports coming from the same host to be treated as port
	  scan sequence.

	  --psd-delay-threshold delay
	  Delay (in hundredths of second) for the packets with different
	  destination ports coming from the same host to be treated as
	  possible port scan subsequence.

	  --psd-lo-ports-weight weight
	  Weight of the packet with privileged (<=1024) destination port.

	  --psd-hi-ports-weight weight
	  Weight of the packet with non-priviliged destination port.

	  To compile it as a module, choose M here.  If unsure, say N.  

config NETFILTER_XT_MATCH_QUOTA2
	tristate '"QUOTA2" match support'
	depends on NETFILTER_XTABLES
	---help---
	  The "quota2" implements a named counter which can be increased or decreased
	  on a per-match basis. Available modes are packet counting or byte counting.
	  The value of the counter can be read and reset through procfs, thereby making
	  this match a minimalist accounting tool.

	  When counting down from the initial quota, the counter will stop at 0 and
	  the match will return false, just like the original "quota" match. In growing
	  (upcounting) mode, it will always return true.

	  --grow
	  Count upwards instead of downwards.

	  --no-change
	  Makes it so the counter or quota amount is never changed by packets matching
	  this rule. This is only really useful in "quota" mode, as it will allow you to
	  use complex prerouting rules in association with the quota system, without
	  counting a packet twice.

	  --name name
	  Assign the counter a specific name. This option must be present, as an empty
	  name is not allowed. Names starting with a dot or names containing a slash are
	  prohibited.

	  [!] --quota iq
	  Specify the initial quota for this counter. If the counter already exists,
	  it is not reset. An "!" may be used to invert the result of the match. The
	  negation has no effect when --grow is used.

	  --packets
	  Count packets instead of bytes that passed the quota2 match.

	  Because counters in quota2 can be shared, you can combine them for various
	  purposes, for example, a bytebucket filter that only lets as much traffic go
	  out as has come in:

	  -A INPUT -p tcp --dport 6881 -m quota --name bt --grow;
	  -A OUTPUT -p tcp --sport 6881 -m quota --name bt;

	  To compile it as a module, choose M here.  If unsure, say N.  

endif # NETFILTER_XTABLES

endmenu

source "net/netfilter/ipset/Kconfig"

source "net/netfilter/ipvs/Kconfig"
